%!TEX root = jsba_main.tex
% Theoretical background 

\section{Theoretical Background}
\label{sec:theo}

\subsection{Distributed Databases}
\label{sec:theo_ddb}

\subsubsection{Terminology}
\label{sec:theo_ddb_term}
A \emph{distributed database}~(DDB) can be defined as multiple, logically interconnected databases spread across a computer network~\cite[p.~4]{Ozsu1991}, such 
that the physical presence of the data may be dispersed spatially instead of having one single database hoarding all the data at a certain location physically. 
On top of this DDB, there is often a so-called \emph{distributed database management system}~(DDBMS) which manages the underlying databases and the access to the
data, and the users are enabled to work with the data of the DDB without noticing the physically distribution, i.e. in a transparent 
manner~\cite[p.~4f.]{Ozsu1991}.
This results, from the point of view of a user, in a logically single database, which can be queried in the same way as a non-distributed database. Furthermore, 
users can benefit from a physical distribution of the data depending on an architectural design because they can communicate with the geographically closest site 
where one of the databases resides reducing the network communication delay, and concurrent access of the DDB can be handled in a distributed way, too, exploiting 
the fact that more servers imply more computing power for the \emph{distributed database system}~(DDBS). Additionally, a DDBS can provide an improved availability
compared to a non-distributed database when the data is replicated. This implies that the data can be reached from multiple sites even if there is a failure of one
of the databases or of parts of the communication network. In this way, users will have a chance to be able to still retrieve the data regardless of parts of the
database being not available.


A DDBMS can be \emph{homogenous} or \emph{heterogenous} where in a homogenous DDBMS all participating sites share the same DBMS locally and in a heterogenous
DDBMS the sites may have a different DBMS with probably different data models. \todo[inline]{... ?!?!}


\subsubsection{Fragmentation}
\label{sec:theo_ddb_frag}
The relations of distributed databases can be partitioned into fragments of the relations, i.e. the data from the tables is split up and assigned to one or more
of the databases that belong to the DDBS. This \emph{fragmentation} can be achieved by using a certain fragmentation strategy. The resulting fragments can then
be dispersed across the network by mapping the fragments to databases.
One strategy to obtain a fragmentation of the data is the \emph{horizontal fragmentation} \cite[p.~105ff.]{Ozsu1991} that divides a relation into smaller 
portions with only some of tuples that were contained in the original relation, i.e. a relation $R$ can be divided into fragments $F_1, F_2,\dots, F_n$ by 
assigning each tuple $\mu$ of the relation $R$ to a fragment $F_i,~i\in\{1,\dots,n\}$. The result of this is that for all $i\in\{1,\dots,n\}, F_i \subseteq R$.
\todo[inline]{derived frag}
\par
On the other hand, a \emph{vertical fragmentation} \cite[p.~122ff.]{Ozsu1991} is a columnwise division of a relation $R$, such that each of the resulting
fragments $F_1,F_2,\dots,F_n$ has a subset of the attributes of the relation $R$. To identify the original tuple to which a partitioned tuple of one of the
fragments belongs to, it is necessary to have a primary key defined on the relation $R$ which can be stored with the subset of attributes of the tuple that is
assigned to a fragment. If it is not the case that a primary key is set for the relation $R$, then an abstract, maybe randomly generated unique identifier has 
to be introduced, i.e. as additional attribute, to match tuple fragments to their source.


\begin{exmp}
$ $\newline
    \begin{center}
    \begin{tabular}{c|c} 
         $a$ & $b$\\
         \hline
         0 & x \\
         1 & x \\
         2 & y \\
         3 & z \\
         7 & g \\
    \end{tabular}
    \captionof{table}{Relation $R$ with the two attributes $a$ and $b$} \label{tab:r}
    \end{center}
$ $\newline
Consider having three servers $S_1$, $S_2$ and $S_3$ and three fragments $F_i,i\in\{1,2,3\}$, of the relation $R=\{(0,x), (1,x), (2,y), (3,z), (7,g)\}$, 
as shown in Table~\ref{tab:r}, where for the sake of simplicity fragment $F_i$ is placed on server $S_i$. 
A possible horizontal fragmentation is $F_1=\{(0,x), (3,z)\}$, $F_2=\{(1,x), (7,g)\}$ and $F_3=\{(2,y)\}$. This fragmentation is illustrated 
by Table~\ref{tab:r_frag}. Here, each row of the table, i.e. each $\mu \in R$, is assigned to exactly one of the fragments $F_i,~i\in\{1,2,3\}$, 
so there is no duplication of any tuple and the fragments are pairwise disjoint, $F_i \neq F_j$ for $i,j \in \{1,2,3\}$ with $i \neq j$, 
but each tuple $\mu \in R$ is contained in one of the fragments. Hence, the union $F_1 \cup F_2 \cup F_3$ of all the fragments yields the original tuple set,
which means that the partitioned relation $R$ can be reconstructed from the fragments, because each of the original tuples is found in (at least) one
fragment. Due to the fact that this primary horizontal fragmentation is complete and disjoint and that fragmentation can be reverted by reconstruction of the
original relation, the three fragmentation correctness rules \cite[p.~103]{Ozsu1991} are fulfilled.
\begin{table}[h]
    \hspace*{\fill}
    \begin{tabular}{c|c}
        $a$ & $b$\\
        \hline
        0 & x \\
        3 & z
    \end{tabular}
    \hfill
    \begin{tabular}{c|c}
        $a$ & $b$\\
        \hline
        1 & x \\
        7 & g
    \end{tabular}
    \hfill
    \begin{tabular}{c|c}
        $a$ & $b$\\
        \hline
        2 & y \\
         & 
    \end{tabular}
    \hspace*{\fill}
    \caption{Horizontal fragments $F_1$, $F_2$ and $F_3$ (from left to right)}
    \label{tab:r_frag}
\end{table}
\end{exmp}
 